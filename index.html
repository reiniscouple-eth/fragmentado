<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Fragmentado</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000; /* Fundo preto para a página */
      color: #fff;
      font-family: sans-serif;
      overflow: hidden; /* Previne barras de rolagem */
    }
    #sketch-holder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1; /* Canvas atrás do rodapé e controles */
    }
    canvas {
        display: block; /* Remove margem inferior do canvas */
    }
    #controls {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 10; /* Controles acima do canvas */
    }
    #controls button {
      background-color: rgba(50, 50, 50, 0.7);
      color: white;
      border: 1px solid rgba(255,255,255,0.5);
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 12px;
    }
    #controls button:hover {
      background-color: rgba(70, 70, 70, 0.9);
    }
    #footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: black;
      color: white;
      text-align: center;
      padding: 10px 0;
      font-size: 14px;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      z-index: 10; /* Rodapé acima do canvas */
      border-top: 1px solid #222; /* Linha sutil de separação */
    }
  </style>
</head>
<body>
  
  <div id="sketch-holder">
    </div>

  <div id="controls">
    <button id="resetButton" title="Reiniciar Imagem">REINICIAR</button>
  </div>
  
  <div id="footer">
    Fragmentado by Reiniscouple
  </div>

  <script>
    let imgPathA = 'assets/image_a.jpg'; // Para paisagem
    let imgPathB = 'assets/image_b.jpg'; // Para retrato
    let chosenImgPath;
    let originalImage;
    let deconstructedImage; // p5.Graphics buffer
    let imgLoaded = false;

    // Variáveis para dimensionamento e posicionamento da imagem
    let drawX, drawY, drawW, drawH;
    let imgScale; // Escala efetiva do conteúdo da imagem

    function preload() {
      // Determina a orientação e escolhe a imagem ANTES de carregar
      if (window.innerWidth >= window.innerHeight) { // Paisagem ou quadrado
        chosenImgPath = imgPathA;
        console.log("Modo paisagem detectado, carregando:", chosenImgPath);
      } else { // Retrato
        chosenImgPath = imgPathB;
        console.log("Modo retrato detectado, carregando:", chosenImgPath);
      }
      
      originalImage = loadImage(chosenImgPath, 
        () => { 
          console.log("Imagem carregada com sucesso:", chosenImgPath);
          imgLoaded = true; 
        }, 
        (err) => {
          console.error("ERRO AO CARREGAR IMAGEM:", chosenImgPath, "- Verifique se o arquivo existe na pasta 'assets' e se o caminho está correto.", err);
          imgLoaded = false; // Mantém como false para exibir mensagem de erro
        }
      );
    }

    function setup() {
      let cnv = createCanvas(windowWidth, windowHeight);
      cnv.parent('sketch-holder');
      cnv.style('display', 'block');

      if (imgLoaded && originalImage.width > 0) {
        calculateImageDisplayDimensions();
        initializeDeconstructedImage();
      } else {
        // Mensagem de erro se o carregamento em preload falhou
        background(20); // Fundo escuro para erro
        textAlign(CENTER, CENTER);
        fill(200);
        textSize(16);
        text(`Erro ao carregar a imagem: ${chosenImgPath}\n\nVerifique se o arquivo existe em 'assets/'\ne se o nome está correto (image_a.jpg ou image_b.jpg).`, width / 2, height / 2);
      }
      
      let resetButton = select('#resetButton');
      if (resetButton) {
        resetButton.mousePressed(resetImage);
      }

      pixelDensity(1); 
      // console.log("Sketch iniciado. Arraste o mouse/dedo sobre a imagem.");
    }

    function calculateImageDisplayDimensions() {
      if (!originalImage || originalImage.width === 0) return;

      let canvasW = windowWidth;
      let canvasH = windowHeight;
      let imgW = originalImage.width;
      let imgH = originalImage.height;

      let canvasAspect = canvasW / canvasH;
      let imageAspect = imgW / imgH;

      // Lógica para "cover" (cobrir a tela, mantendo aspect ratio, cortando excessos)
      if (imageAspect > canvasAspect) { 
        // Imagem mais larga que o canvas: ajustar altura, centralizar largura
        drawH = canvasH;
        drawW = imgW * (canvasH / imgH);
        drawX = (canvasW - drawW) / 2;
        drawY = 0;
        imgScale = canvasH / imgH;
      } else { 
        // Imagem mais alta que o canvas (ou mesma proporção): ajustar largura, centralizar altura
        drawW = canvasW;
        drawH = imgH * (canvasW / imgW);
        drawX = 0;
        drawY = (canvasH - drawH) / 2;
        imgScale = canvasW / imgW;
      }
      // console.log(`Dimensões de desenho: X:${drawX.toFixed(2)}, Y:${drawY.toFixed(2)}, W:${drawW.toFixed(2)}, H:${drawH.toFixed(2)}, Scale:${imgScale.toFixed(2)}`);
    }

    function initializeDeconstructedImage() {
      if (originalImage && originalImage.width > 0) {
        deconstructedImage = createGraphics(originalImage.width, originalImage.height);
        deconstructedImage.image(originalImage, 0, 0); 
        imgLoaded = true; // Garante que está true
        console.log("Buffer de desconstrução (re)inicializado.");
      } else {
         imgLoaded = false;
         console.error("Falha ao inicializar buffer: imagem original inválida.");
      }
    }

    function resetImage() {
        if (imgLoaded && originalImage && originalImage.width > 0) {
            console.log("Reiniciando imagem desconstruída.");
            initializeDeconstructedImage(); 
        } else {
            console.log("Nenhuma imagem carregada para reiniciar. Tentando recarregar a imagem definida pela orientação...");
            // Tenta recarregar a imagem baseada na orientação atual
            // Isso é um pouco mais complexo pois loadImage é assíncrono
            // Uma abordagem mais simples é apenas alertar o usuário ou não fazer nada se não houver img original
            if(!originalImage || originalImage.width === 0) {
                 alert("Não há imagem original carregada. Verifique os arquivos em 'assets/'.");
            }
        }
    }

    function draw() {
      if (!imgLoaded || !deconstructedImage) {
        // Se o carregamento falhou, a mensagem de erro do setup é exibida.
        // Se estivesse carregando ativamente (improvável aqui pois preload bloqueia):
        if (!imgLoaded) { // Reforça a mensagem se algo deu muito errado
            background(20); fill(200); textAlign(CENTER, CENTER); textSize(16);
            text(`Aguardando imagem ou falha no carregamento: ${chosenImgPath || 'Nenhuma imagem selecionada.'}`, width/2, height/2);
        }
        return;
      }
      
      background(0); // Limpa o canvas principal com preto
      image(deconstructedImage, drawX, drawY, drawW, drawH); 
    }

    function getMappedMouseCoordinates() {
        if (!originalImage || !imgLoaded || !deconstructedImage) return null;

        let mx = mouseX;
        let my = mouseY;

        if (mx < drawX || mx > drawX + drawW || my < drawY || my > drawY + drawH) {
            return null; // Mouse fora da área da imagem visível
        }

        let imgMouseX = (mx - drawX) / imgScale;
        let imgMouseY = (my - drawY) / imgScale;
        
        imgMouseX = constrain(imgMouseX, 0, deconstructedImage.width - 1);
        imgMouseY = constrain(imgMouseY, 0, deconstructedImage.height - 1);

        return { x: imgMouseX, y: imgMouseY };
    }

    function mouseDragged() {
        if (imgLoaded && deconstructedImage) {
            let mappedCoords = getMappedMouseCoordinates();
            if (mappedCoords) {
                applyDeconstructionEffect(mappedCoords.x, mappedCoords.y);
            }
        }
        return false; 
    }

    function touchMoved() { // Garante funcionamento em mobile
        mouseDragged(); // Chama a mesma lógica
        return false;
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      if (imgLoaded && originalImage && originalImage.width > 0) {
        // Recalcula como a imagem atual deve ser exibida na nova dimensão da tela
        calculateImageDisplayDimensions(); 
        // Nota: Não troca a imagem (paisagem/retrato) dinamicamente aqui,
        // pois isso exigiria recarregar a imagem, o que é assíncrono e
        // geralmente feito em preload. A escolha da imagem é feita no carregamento inicial.
      } else if (!imgLoaded) {
        // Se a imagem não carregou, e a tela foi redimensionada,
        // pode ser útil tentar exibir a mensagem de erro novamente ou uma mensagem genérica.
        background(20); textAlign(CENTER, CENTER); fill(200); textSize(16);
        text(`Erro ao carregar imagem. Verifique 'assets/' e atualize.`, width / 2, height / 2);
      }
    }

    function applyDeconstructionEffect(imgMx, imgMy) {
      if (!deconstructedImage || !originalImage) return;

      let baseBrushDim = min(originalImage.width, originalImage.height);
      let brushRadius = constrain(baseBrushDim * 0.1, 25, 180) ; // Aumentei um pouco o raio relativo
      let numOperations = 20; // Aumentei as operações para um efeito mais denso
      
      deconstructedImage.push();
      deconstructedImage.noStroke();

      for (let i = 0; i < numOperations; i++) {
        let blockSize = random(5, constrain(brushRadius * 0.35, 5, 60)); 
        let maxOffset = brushRadius * 0.6;    

        let angle = random(TWO_PI);
        let distFromCenter = random(brushRadius); // Permite pegar blocos de toda a área do pincel
        
        let sampleX = imgMx + cos(angle) * distFromCenter;
        let sampleY = imgMy + sin(angle) * distFromCenter;

        let sX = floor(constrain(sampleX - blockSize / 2, 0, originalImage.width - blockSize));
        let sY = floor(constrain(sampleY - blockSize / 2, 0, originalImage.height - blockSize));

        if (sX < 0 || sY < 0 || sX + floor(blockSize) > originalImage.width || sY + floor(blockSize) > originalImage.height || blockSize <= 0.5) continue; 
        
        let blockToMove;
        try {
            blockToMove = deconstructedImage.get(sX, sY, floor(blockSize), floor(blockSize));
        } catch (e) {
            // console.warn("Erro em .get(): ", sX, sY, floor(blockSize), floor(blockSize), e);
            continue; // Pula esta iteração se .get() falhar
        }

        let offsetX = random(-maxOffset, maxOffset);
        let offsetY = random(-maxOffset, maxOffset);
        
        let targetX = sX + offsetX; 
        let targetY = sY + offsetY;

        let tX = floor(constrain(targetX, 0, originalImage.width - blockSize));
        let tY = floor(constrain(targetY, 0, originalImage.height - blockSize));

        if (blockToMove && blockToMove.width > 0 && blockToMove.height > 0) { 
            deconstructedImage.image(blockToMove, tX, tY);
        }
      }
      deconstructedImage.pop();
    }
  </script>
</body>
</html>
